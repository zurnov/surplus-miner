<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="theme-color" content="#0e1116" />
  <title>Surplus Miner Control</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
  <style>
    /* Accessibility / Theming additions */
    :root{
      --bg:#0e1116; --panel:#141824; --muted:#8b91a6; --fg:#e9ecf3; --accent:#6aa0ff;
      --ok:#2ecc71; --warn:#f1c40f; --bad:#e74c3c; --line:#222637; --chip:#1a2031;
      --space-xs:4px; --space-s:8px; --space:12px; --space-l:16px; --radius:14px;
      --transition: .18s cubic-bezier(.4,.2,.2,1);
    }
    *{ box-sizing:border-box }
    html,body{ height:100% }
    body{
      margin:0; background:var(--bg); color:var(--fg);
      font-family:Inter, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica, Arial;
      -webkit-font-smoothing:antialiased; -moz-osx-font-smoothing:grayscale;
    }
    header{
      position:sticky; top:0; z-index:5; background:linear-gradient(180deg, #0e1116 0%, #0e1116ee 70%, #0e111600 100%);
      backdrop-filter: blur(6px);
      border-bottom:1px solid var(--line);
    }
    .topbar{ max-width:1200px; margin:0 auto; padding:14px 16px; display:flex; align-items:center; gap:12px; }
    .brand{ font-weight:600; letter-spacing:.2px; font-size:15px }
    .spacer{ flex:1 }
    .chip{ display:inline-flex; align-items:center; gap:8px; padding:6px 10px; border:1px solid var(--line); background:var(--chip); border-radius:999px; font-size:12px; color:var(--muted) }
    .dot{ width:8px; height:8px; border-radius:50%; background:#777 }
    .dot.ok{ background:var(--ok) } .dot.warn{ background:var(--warn) } .dot.bad{ background:var(--bad) }

    main{ max-width:1200px; margin:18px auto 28px; padding:0 16px; display:grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap:12px }
    .card{ background:var(--panel); border:1px solid var(--line); border-radius:var(--radius); padding:14px; box-shadow:0 6px 26px rgba(0,0,0,.22) }
    /* Wider auto control card: span 2 columns on wide screens */
    .card.auto-card{ grid-column: span 2; min-width:560px; }
    @media (max-width: 1000px){
      .card.auto-card{ grid-column:1 / -1; min-width:0; }
    }
    /* Prevent inner KV with buttons from wrapping prematurely */
    .auto-card .row .kv[title]{ flex-wrap:nowrap; white-space:nowrap; }
    .auto-card .row .kv[title] button{ white-space:nowrap; }

    .label{ color:var(--muted); font-size:12px; text-transform:uppercase; letter-spacing:.6px }
    .value{ font-size:24px; font-weight:600; margin-top:4px }
    .row{ display:flex; align-items:center; gap:8px; margin-top:8px; color:var(--muted); flex-wrap:wrap }
    .kv{ display:flex; align-items:center; gap:6px; background:var(--chip); border:1px solid var(--line); padding:5px 9px; border-radius:8px; font-size:12px }
    .right{ margin-left:auto }
    .pill{ padding:4px 8px; border-radius:999px; border:1px solid var(--line); font-size:12px; color:var(--muted) }
    .pill.ok{ color:var(--ok); border-color:#224b35; background:#12261c }
    .pill.warn{ color:var(--warn); border-color:#4b4522; background:#262112 }
    .pill.bad{ color:var(--bad); border-color:#4b2222; background:#261212 }

    /* Miners grid */
    .miners{ grid-column:1 / -1 }
    .miners-grid{ display:grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap:12px; margin-top:12px }
    .miner-card{ padding:16px; border-radius:12px; background:var(--panel); border:1px solid var(--line) }
    .miner-head{ display:flex; align-items:center; gap:10px; margin-bottom:10px }
    .miner-host{ font-weight:600 }
    .metric-row{ display:grid; grid-template-columns: repeat(3, 1fr); gap:10px; margin-top:6px }
    .metric{ background:var(--chip); border:1px solid var(--line); border-radius:10px; padding:10px }
    .metric .k{ color:var(--muted); font-size:11px; text-transform:uppercase; letter-spacing:.5px }
    .metric .v{ font-weight:600; margin-top:4px; font-size:18px }

    .controls{ display:flex; gap:8px; align-items:center; margin-top:12px; flex-wrap:wrap }
    input[type=number]{
      -moz-appearance: textfield; appearance:textfield; width:112px; padding:8px 10px; border-radius:8px;
      border:1px solid var(--line); background:#0f1320; color:var(--fg); outline:none;
    }
    input[type=number]::-webkit-outer-spin-button, input[type=number]::-webkit-inner-spin-button{ -webkit-appearance: none; margin: 0; }
    button{
      cursor:pointer; padding:8px 12px; border-radius:8px; border:1px solid var(--line);
      background:#1b2340; color:#e9ecf3; font-weight:600; letter-spacing:.2px; transition:.15s ease all;
    }
    button:hover{ filter:brightness(1.1) }
    .btn-primary{ background:#2b5cff; border-color:#2b5cff }
    .btn-danger{ background:#e74c3c; border-color:#c74233 }
    .btn-warn{ background:#444; border-color:#333 }
    .btn-ok{ background:#2ecc71; border-color:#27ae60 }

    .is-disabled{ opacity:.6; pointer-events:none }

    .switch{ position:relative; display:inline-block; width:46px; height:26px; }
    .switch input{ opacity:0; width:0; height:0 }
    .slider{ position:absolute; cursor:pointer; top:0; left:0; right:0; bottom:0; background:#333; transition:.2s; border-radius:999px; border:1px solid var(--line) }
    .slider:before{ position:absolute; content:""; height:20px; width:20px; left:3px; bottom:3px; background:white; transition:.2s; border-radius:50% }
    input:checked + .slider{ background:#2b5cff }
    input:checked + .slider:before{ transform:translateX(20px) }

    footer{ max-width:1200px; margin:8px auto 24px; padding:0 16px; color:var(--muted); font-size:12px }
    a{ color:var(--accent); text-decoration:none }

    /* Performance mini cards */
    .mini-note{ font-size:11px; color:var(--muted); margin-top:2px }
    .trend-up{ color:var(--ok); }
    .trend-down{ color:var(--bad); }

    /* Toast system */
    .toasts{ position:fixed; bottom:18px; right:18px; display:flex; flex-direction:column; gap:10px; z-index:50; max-width:320px; }
    .toast{ background:rgba(28,34,48,.92); border:1px solid var(--line); padding:10px 14px; border-radius:10px; font-size:13px; display:flex; align-items:center; gap:10px; box-shadow:0 4px 18px -4px rgba(0,0,0,.5); opacity:0; transform:translateY(6px); animation:toast-in .35s var(--transition) forwards; }
    .toast.ok{ border-color:#234f38; background:#16251d; }
    .toast.warn{ border-color:#4b4522; background:#262112; }
    .toast.bad{ border-color:#4b2222; background:#261212; }
    .toast button{ background:transparent; border:none; color:var(--muted); font-size:16px; padding:2px 4px; cursor:pointer; }
    @keyframes toast-in{ to{ opacity:1; transform:translateY(0) } }
    @keyframes toast-out{ to{ opacity:0; transform:translateY(6px) } }

    /* Focus visibility */
    :focus-visible{ outline:2px solid var(--accent); outline-offset:2px; }

    /* Reduced motion */
    @media (prefers-reduced-motion: reduce){
      *{ animation-duration:.001ms !important; animation-iteration-count:1 !important; transition:none !important }
    }
    @media (max-width:640px){
      main{ grid-template-columns: repeat(auto-fit, minmax(240px,1fr)); }
    }
    /* High contrast mode support */
    @media (forced-colors: active){
      .card, .kv, .metric, input, button{ forced-color-adjust:auto; }
    }
    /* Focus ring for cards interactive areas */
    .miner-card:focus-within{ box-shadow:0 0 0 2px #2b5cff55; }
    /* Efficiency & absorption metric styling reuse existing classes */
  </style>
</head>
<body>
  <header>
    <div class="topbar">
      <h1 class="brand" style="margin:0; font-size:15px">Surplus Miner Control</h1>
      <div class="chip" id="conn-chip" role="status" aria-live="polite"><span class="dot" id="conn-dot"></span><span id="conn-text">Connecting…</span></div>
      <div class="chip">Last update: <span id="last-update" style="margin-left:6px">—</span></div>
      <div class="spacer"></div>
      <div class="chip">Backend: <span id="backend-url" style="margin-left:6px"></span></div>
    </div>
  </header>

  <main>
    <!-- Grid Power -->
    <section class="card">
      <h2 class="label" id="grid-power-label">Grid Power</h2>
      <div class="value" id="grid-total" aria-labelledby="grid-power-label">—</div>
      <div class="row" aria-label="Per phase grid power">
        <div class="kv">L1: <span id="grid-l1">—</span></div>
        <div class="kv">L2: <span id="grid-l2">—</span></div>
        <div class="kv">L3: <span id="grid-l3">—</span></div>
        <span class="right pill" id="grid-pill">Idle</span>
      </div>
    </section>

    <!-- Consumption -->
    <section class="card">
      <h2 class="label" id="consumption-label">Consumption</h2>
      <div class="value" id="cons-total" aria-labelledby="consumption-label">—</div>
      <div class="row" aria-label="Per phase consumption">
        <div class="kv">L1: <span id="cons-l1">—</span></div>
        <div class="kv">L2: <span id="cons-l2">—</span></div>
        <div class="kv">L3: <span id="cons-l3">—</span></div>
      </div>
    </section>

    <!-- Total Hashrate -->
    <section class="card" id="card-total-hash">
      <h2 class="label" id="hashrate-label">Total Hashrate</h2>
      <div class="value" id="total-ths" aria-labelledby="hashrate-label">—</div>
      <div class="row">
        <div class="kv">Miners: <span id="miners-count">—</span></div>
      </div>
    </section>

    <!-- Miner Consumption -->
    <section class="card" id="card-total-consumption">
      <h2 class="label" id="miner-consumption-label">Miner Consumption</h2>
      <div class="value" id="total-miner-power" aria-labelledby="miner-consumption-label">—</div>
      <div class="row">
        <div class="kv">Avg / Miner: <span id="avg-miner-power">—</span></div>
      </div>
    </section>

    <!-- Efficiency -->
    <section class="card" id="card-efficiency">
      <h2 class="label" id="eff-label">Efficiency</h2>
      <div class="value" id="eff-ths-kw" aria-labelledby="eff-label">—</div>
      <div class="row">
        <div class="kv" title="Joules per Terahash (lower is better)">J/TH: <span id="eff-jth">—</span></div>
        <div class="kv" title="TH/s per kW (higher is better)">TH/kW: <span id="eff-thkw">—</span></div>
      </div>
    </section>

    <!-- Surplus Absorption -->
    <section class="card" id="card-absorption">
      <h2 class="label" id="absorb-label">Surplus Absorption</h2>
      <div class="value" id="absorption-percent" aria-labelledby="absorb-label">—</div>
      <div class="row">
        <div class="kv" title="Estimated surplus being utilized by miners">Absorbed: <span id="absorption-watts">—</span></div>
        <div class="kv" title="Current export (if negative grid power)">Export: <span id="export-watts">—</span></div>
      </div>
    </section>

    <!-- Auto Control -->
    <section class="card auto-card">
      <h2 class="label" id="auto-label">Auto Control</h2>
      <div class="row" style="margin-top:8px">
        <label class="switch" title="Enable or disable automatic solar surplus control">
          <input type="checkbox" id="auto-toggle" aria-labelledby="auto-switch-label" />
          <span class="slider"></span>
        </label>
        <span id="auto-status" class="pill warn" role="status" aria-live="polite">Checking…</span>
        <span class="kv" id="auto-avg">Avg grid: —</span>
        <span class="spacer"></span>
        <div class="kv" title="Quick set all miners to a fixed target when Auto is OFF">
          All:
          <button class="btn-warn" data-all="800" type="button">800W</button>
          <button class="btn-warn" data-all="1000" type="button">1000W</button>
          <button class="btn-warn" data-all="1420" type="button">1420W</button>
          <button class="btn-warn" data-all="100" type="button">Pause</button>
          <button class="btn-danger" data-all="0" type="button">Stop</button>
        </div>
      </div>
      <p class="row" style="font-size:12px; color:var(--muted); margin-top:4px" aria-describedby="auto-label">
        Auto distributes solar surplus across miners in steps and pauses miners if no surplus persists. Manual controls are disabled while Auto is ON.
      </p>
    </section>

    <!-- Miners -->
    <section class="card miners">
      <h2 class="label" id="miners-label">Miners</h2>
      <div class="miners-grid" id="miners-grid" aria-labelledby="miners-label"></div>
    </section>
  </main>

  <footer>
    Real-time grid and consumption via Victron MQTT. Per-miner control uses PAPI + SSH through the backend.
  </footer>

  <!-- Toast container -->
  <div class="toasts" id="toasts" role="region" aria-live="polite" aria-label="Notifications"></div>

  <script src="https://cdn.socket.io/4.8.1/socket.io.min.js"></script>
  <script>
    // Configuration
    const API_BASE = 'http://localhost:3099'; // Backend base URL
    document.getElementById('backend-url').textContent = API_BASE;

    // Utilities
    const $ = (id) => document.getElementById(id);
    const fmtW = (w) => (w == null || isNaN(w)) ? '—' : `${Math.round(w).toLocaleString()} W`;
    const fmtTHs = (ths) => (ths == null || isNaN(ths)) ? '—' : `${Number(ths).toFixed(2)} TH/s`;
    const fmtUptime = (sec) => {
      // Treat 0s as valid and show 0m
      if (sec == null || !isFinite(sec)) return '—';
      const d = Math.floor(sec/86400), h = Math.floor((sec%86400)/3600), m = Math.floor((sec%3600)/60);
      const a=[]; if (d) a.push(`${d}d`); if (h) a.push(`${h}h`); if (m || (!d && !h)) a.push(`${m}m`); return a.join(' ');
    };
    const gridClass = (w) => w <= -50 ? 'ok' : (Math.abs(w) < 50 ? 'warn' : 'bad');

    // Connection chip
    function setConn(status){
      const dot=$('conn-dot'), txt=$('conn-text');
      dot.classList.remove('ok','warn','bad');
      if(status==='connected'){ dot.classList.add('ok'); txt.textContent='Connected'; }
      else if(status==='reconnecting'){ dot.classList.add('warn'); txt.textContent='Reconnecting…'; }
      else { dot.classList.add('bad'); txt.textContent='Disconnected'; }
    }

    // Grid + Consumption rendering
    function renderPower(payload){
      if(!payload) return;
      const p = payload.power || {}; const c = payload.consumption || {};
      const pt = Number(p.total ?? (p.l1||0)+(p.l2||0)+(p.l3||0));
      lastGridPowerTotal = isFinite(pt) ? pt : lastGridPowerTotal; // store for absorption calc
      const ct = Number(c.total ?? (c.l1||0)+(c.l2||0)+(c.l3||0));
      $('grid-total').textContent = fmtW(pt);
      $('grid-l1').textContent = fmtW(p.l1);
      $('grid-l2').textContent = fmtW(p.l2);
      $('grid-l3').textContent = fmtW(p.l3);
      $('cons-total').textContent = fmtW(ct);
      $('cons-l1').textContent = fmtW(c.l1);
      $('cons-l2').textContent = fmtW(c.l2);
      $('cons-l3').textContent = fmtW(c.l3);

      const pill=$('grid-pill'); pill.classList.remove('ok','warn','bad'); pill.classList.add(gridClass(pt));
      pill.textContent = pt <= -50 ? 'Exporting (Surplus)' : (Math.abs(pt) < 50 ? 'Near Zero' : 'Getting Power (Deficit)');

      $('last-update').textContent = new Date(payload.timestamp || Date.now()).toLocaleTimeString();
      // Recompute absorption immediately after power update
      try { updateTotals(); } catch(_){ }
    }

    // Auto Control state
    const auto = { enabled:false, lastAvgGridPower: null, perMinerTargets:{} };

    function renderAuto(){
      const t=$('auto-toggle'); const st=$('auto-status'); const avg=$('auto-avg');
      t.checked = !!auto.enabled;
      st.classList.remove('ok','warn','bad');
      if (auto.enabled){ st.textContent='Auto: Enabled'; st.classList.add('ok'); }
      else { st.textContent='Auto: Disabled'; st.classList.add('bad'); }
      if (auto.lastAvgGridPower != null) avg.textContent = 'Avg grid: ' + fmtW(auto.lastAvgGridPower);
      // Dim manual controls when auto is on
      document.querySelectorAll('.miner-card .controls').forEach(el=>{
        if (auto.enabled) el.classList.add('is-disabled'); else el.classList.remove('is-disabled');
      });
      // annotate miner cards with auto targets
      document.querySelectorAll('.miner-card').forEach(card=>{
        const idx = Number(card.getAttribute('data-index'));
        const host = minerState[idx]?.host || minerState[idx]?.ip;
        const tgt = auto.perMinerTargets?.[host];
        let badge = card.querySelector('[data-k="auto-badge"]');
        if (!badge){
          const head = card.querySelector('.miner-head');
          badge = document.createElement('span');
          badge.setAttribute('data-k','auto-badge');
          badge.className = 'pill warn';
          head.appendChild(badge);
        }
        if (auto.enabled && tgt != null){
          badge.style.display='inline-flex';
          const paused = Number(tgt) <= 150;
          badge.classList.remove('ok','warn','bad');
          badge.classList.add(paused ? 'warn' : 'ok');
          badge.textContent = paused ? 'Auto paused' : `Auto target: ${Math.round(tgt)}W`;
        } else {
          badge.style.display='none';
        }
      });
    }

    // Miners UI
    const minersGrid = $('miners-grid');
    let minerState = []; // cached array

    function getNum(...vals){
      for(const v of vals){ const n = Number(v); if (isFinite(n)) return n; }
      return null;
    }

    // Parse a hashrate string like "12.34 TH/s", "850 GH/s", or "700000 MH/s" into TH/s
    function parseRateToTHs(str){
      if (typeof str !== 'string') return null;
      const s = str.trim();
      const m = s.match(/([\d.]+)\s*([TGMK]?H)\/?s?/i);
      if (m) {
        const val = parseFloat(m[1]);
        if (!isFinite(val)) return null;
        const unit = (m[2] || 'TH').toUpperCase();
        if (unit.startsWith('T')) return val;
        if (unit.startsWith('G')) return val/1000;
        if (unit.startsWith('M')) return val/1e6;
        if (unit.startsWith('K')) return val/1e9;
        return val; // assume TH if unknown
      }
      const n = parseFloat(s);
      return isFinite(n) ? n : null;
    }

    function getTHs(m){
      // Prefer explicit numeric fields
      const thsDirect = getNum(m?.hashrateThs, m?.ths, m?.hashrateTHs);
      if (thsDirect != null) return thsDirect;
      // Common cgminer totals
      if (m && (m['GHS 5s'] != null || m.GHS5s != null)) {
        const g = getNum(m['GHS 5s'], m.GHS5s);
        if (g != null) return g/1000;
      }
      if (m && (m['MHS 5s'] != null || m.MHS5s != null || m.mhs5s != null || m.mhs_5s != null)) {
        const mh = getNum(m['MHS 5s'], m.MHS5s, m.mhs5s, m.mhs_5s);
        if (mh != null) return mh/1e6;
      }
      // Parse hashrate string, if present
      const str = m?.hashrate;
      const parsed = parseRateToTHs(str);
      if (parsed != null) return parsed;
      // Sum per-chain hashrates if available on m.devs
      if (Array.isArray(m?.devs) && m.devs.length) {
        let sum = 0, any=false;
        for (const d of m.devs) {
          const v = parseRateToTHs(d?.hashrate);
          if (v != null) { sum += v; any = true; }
        }
        if (any) return sum;
      }
      return null;
    }

    function getPower(m){
      return getNum(m?.powerW, m?.totalPower, m?.power, m?.power_total, m?.power_now);
    }

    // Parse uptime strings like "1d 2h 3m", "12:34:56", or "5h" to seconds
    function parseUptimeToSec(val){
      if (val == null) return null;
      if (typeof val === 'number' && isFinite(val)) return val;
      const s = String(val).trim();
      if (!s) return null;
      // d h m s tokens
      let total = 0; let matched = false;
      s.replace(/(\d+)\s*d/ig, (_,d)=>{ total += parseInt(d,10)*86400; matched=true; return ''; });
      s.replace(/(\d+)\s*h/ig, (_,h)=>{ total += parseInt(h,10)*3600; matched=true; return ''; });
      s.replace(/(\d+)\s*m/ig, (_,m)=>{ total += parseInt(m,10)*60; matched=true; return ''; });
      s.replace(/(\d+)\s*s/ig, (_,ss)=>{ total += parseInt(ss,10); matched=true; return ''; });
      if (matched) return total;
      // HH:MM[:SS] or DD:HH:MM:SS
      const parts = s.split(':').map(p=>parseInt(p,10));
      if (parts.every(n=>!isNaN(n))) {
        if (parts.length === 4) return parts[0]*86400 + parts[1]*3600 + parts[2]*60 + parts[3];
        if (parts.length === 3) return parts[0]*3600 + parts[1]*60 + parts[2];
        if (parts.length === 2) return parts[0]*60 + parts[1];
      }
      return null;
    }

    function getUptimeSec(m){
      const sec = getNum(m?.uptimeSec, m?.Elapsed, m?.uptime_seconds, m?.uptime_sec);
      if (sec != null) return sec;
      return parseUptimeToSec(m?.uptime || m?.Uptime);
    }

    function formatUptime(m){
      const sec = getUptimeSec(m);
      if (sec != null) return fmtUptime(sec);
      const s = m?.uptime || m?.Uptime;
      return (typeof s === 'string' && s.trim()) ? s : '—';
    }

    function getStatus(m){
      const s = m?.status || m?.STATUS || m?.state || '';
      if (s === 'S' || /alive|ok|running/i.test(s)) return {text:'Alive', cls:'ok'};
      if (/degrad|warm|starting|init/i.test(s)) return {text:'Degraded', cls:'warn'};
      return {text:'OFFLINE', cls:'bad'}; 
    }

    function minerCardTpl(m, idx){
      const st = getStatus(m);
      return `
        <div class="miner-card" data-index="${idx}">
          <div class="miner-head">
            <div class="miner-host">${m.host || m.ip || 'Miner ' + idx}</div>
            <span class="pill ${st.cls}" title="Status">${st.text}</span>
            <span class="spacer"></span>
          </div>
          <div class="metric-row">
            <div class="metric"><div class="k">TH/s</div><div class="v" data-k="ths">${fmtTHs(getTHs(m))}</div></div>
            <div class="metric"><div class="k">Power</div><div class="v" data-k="power">${fmtW(getPower(m))}</div></div>
            <div class="metric"><div class="k">Uptime</div><div class="v" data-k="uptime">${formatUptime(m)}</div></div>
          </div>
          <div class="row" style="gap:8px; margin-top:10px">
            <div class="kv" title="Active pool URL">Pool: ${m.activePool || '—'}</div>
            <div class="kv" title="Active chains / total">Chains: ${Number(m.activeChains||0)}/${Number(m.chains||0)}</div>
            <div class="kv" title="HW errors">HW: ${Number(m.hwErrors||0)}</div>
          </div>
          <div class="controls">
            <input type="number" min="0" max="1600" step="10" placeholder="Watts" value="${Math.min(1400, Math.max(0, Math.round(getPower(m) || 1200)))}" />
            <button class="btn-primary" data-act="apply">Apply</button>
            <button class="btn-warn" data-act="set-800">800W</button>
            <button class="btn-warn" data-act="set-1000">1000W</button>
            <button class="btn-warn" data-act="set-1420">1420W</button>
            <button class="btn-danger" data-act="pause">Pause</button>
            <button class="btn-warn" data-act="stop">Stop</button>
            <button class="btn-ok" data-act="resume">Resume</button>
          </div>
          <div class="row" style="font-size:12px" data-k="msg"></div>
        </div>`;
    }

    function renderMiners(miners){
      minerState = Array.isArray(miners?.miners) ? miners.miners : (Array.isArray(miners) ? miners : []);
      minersGrid.innerHTML = minerState.map(minerCardTpl).join('');
      // Wire controls
      minersGrid.querySelectorAll('.miner-card').forEach(card => {
        const idx = Number(card.getAttribute('data-index'));
        card.addEventListener('click', async (e) => {
          const btn = e.target.closest('button'); if(!btn) return;
          const act = btn.getAttribute('data-act');
          const input = card.querySelector('input[type=number]');
          const msg = card.querySelector('[data-k="msg"]');
          msg.textContent = '';
          try{
            if (act === 'set-800' || act === 'set-1000' || act === 'set-1420') {
              const watts = act === 'set-800' ? 800 : (act === 'set-1000' ? 1000 : 1420);
              input.value = watts;
              // fall through to apply
              await fetch(`${API_BASE}/api/power-target?miner=${idx}`,{
                method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ watts })
              }).then(r=>{ if(!r.ok) throw new Error('Failed'); return r.json(); });
              msg.textContent = `Applied ${watts} W`;
            } else if (act === 'apply') {
              const watts = Number(input.value);
              if (!isFinite(watts) || watts < 0 || watts > 1600) throw new Error('Enter 0–1600 W');
              await fetch(`${API_BASE}/api/power-target?miner=${idx}`,{
                method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ watts })
              }).then(r=>{ if(!r.ok) throw new Error('Failed'); return r.json(); });
              msg.textContent = `Applied ${watts} W`;
            } else if (act === 'pause') {
              const watts = 100; // low-power pause
              await fetch(`${API_BASE}/api/power-target?miner=${idx}`,{
                method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ watts })
              }).then(r=>{ if(!r.ok) throw new Error('Failed'); return r.json(); });
              input.value = watts;
              msg.textContent = 'Paused at 100 W';
            } else if (act === 'stop') {
              await fetch(`${API_BASE}/api/power-target?miner=${idx}`,{
                method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ shutdown:true })
              }).then(r=>{ if(!r.ok) throw new Error('Failed'); return r.json(); });
              msg.textContent = 'Stopping BOSminer…';
            } else if (act === 'resume') {
              await fetch(`${API_BASE}/api/power-target?miner=${idx}`,{
                method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ resume:true })
              }).then(r=>{ if(!r.ok) throw new Error('Failed'); return r.json(); });
              msg.textContent = 'Resuming BOSminer…';
            }
            // refresh row soon after action
            setTimeout(loadMiners, 1200);
          }catch(err){ msg.textContent = String(err.message || err); }
        });
      });
      renderAuto();
    }

    async function loadMiners(){
      try{
        const res = await fetch(`${API_BASE}/api/miners`, { cache:'no-store' });
        if(!res.ok) throw new Error('Miners API error');
        const data = await res.json();
        renderMiners(data);
      }catch(err){
        // show empty grid message on failure
        if(!minersGrid.dataset.initialized){
          minersGrid.innerHTML = `<div class="miner-card"><div class="miner-head"><div class="miner-host">No data</div><span class="pill bad">Error</span></div><div class="row">${String(err.message || err)}</div></div>`;
        }
      } finally {
        minersGrid.dataset.initialized = '1';
      }
    }

    // Auto toggle handlers
    $('auto-toggle').addEventListener('change', async (e)=>{
      try{
        const enable = e.target.checked;
        const res = await fetch(`${API_BASE}/api/auto-control`,{
          method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ enable })
        });
        if(!res.ok) throw new Error('Failed to update auto control');
        const data = await res.json();
        auto.enabled = !!data.enabled;
        renderAuto();
        showToast('Auto control ' + (auto.enabled?'enabled':'disabled'), auto.enabled?'ok':'warn');
      }catch(err){
        e.target.checked = !e.target.checked;
        showToast('Auto toggle failed: ' + (err.message||err),'bad',5000);
      }
    });

    // Quick set for all miners (when auto is off) - replace alert
    document.addEventListener('click', async (e)=>{
      const btn = e.target.closest('button[data-all]');
      if(!btn) return;
      if (auto.enabled) { showToast('Disable Auto to use quick set for all','warn'); return; }
      const watts = Number(btn.getAttribute('data-all'));
      if (!isFinite(watts)) return;
      try{
        for (let i=0;i<minerState.length;i++){
          await fetch(`${API_BASE}/api/power-target?miner=${i}`,{ method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ watts: watts===100?100:watts, shutdown: watts===0?true:undefined }) });
        }
        showToast('Applied ' + (watts===0?'Stop': watts + 'W') + ' to all','ok');
      }catch(err){
        showToast('Quick set failed','bad');
      } finally {
        setTimeout(loadMiners, 1200);
      }
    });

    // Socket for Victron live and Auto control updates
    let lastSocketUpdate = 0;
    try{
      const socket = io(API_BASE, { transports:['websocket'], timeout: 8000 });
      socket.on('connect', ()=> setConn('connected'));
      socket.on('reconnect_attempt', ()=> setConn('reconnecting'));
      socket.on('disconnect', ()=> setConn('disconnected'));
      socket.on('data_update', (payload)=>{ lastSocketUpdate = Date.now(); renderPower(payload); });
      socket.on('auto_control_update', (payload)=>{ 
        if (payload && typeof payload === 'object'){
          auto.enabled = !!payload.enabled;
          auto.lastAvgGridPower = payload.lastAvgGridPower;
          auto.perMinerTargets = payload.perMinerTargets || {};
          renderAuto();
        }
      });
    }catch{ /* ignore */ }

    // Fallback polling for Victron if socket idle
    async function pollVenus(){
      try{
        if (Date.now() - lastSocketUpdate < 7000) return; // socket is fresh
        const res = await fetch(`${API_BASE}/api/venus`, { cache:'no-store' });
        if(!res.ok) throw new Error('Venus API error');
        const data = await res.json();
        renderPower(data);
      }catch{ /* ignore */ }
    }

    // Initial fetch for Auto state
    async function loadAuto(){
      try{
        const res = await fetch(`${API_BASE}/api/auto-control`, { cache:'no-store' });
        if (!res.ok) throw new Error('Auto API error');
        const data = await res.json();
        auto.enabled = !!data.enabled;
        auto.lastAvgGridPower = data.lastAvgGridPower;
        auto.perMinerTargets = data.perMinerTargets || {};
        renderAuto();
      }catch(err){ /* ignore */ }
    }

    // Kick off loops
    loadAuto();
    loadMiners();
    setInterval(loadMiners, 5000);
    pollVenus();
    setInterval(pollVenus, 5000);

    // Globals for new metrics
    let lastGridPowerTotal = null;
    let lastEfficiency = null;

    function showToast(msg, type='ok', ttl=3200){
      try{
        const wrap = document.getElementById('toasts'); if(!wrap) return;
        const el = document.createElement('div'); el.className = 'toast ' + (type||'');
        el.innerHTML = `<span style="flex:1;">${msg}</span><button title="Dismiss" aria-label="Dismiss notification">×</button>`;
        wrap.appendChild(el);
        const remove=()=>{ el.style.animation='toast-out .25s forwards'; setTimeout(()=>el.remove(), 260); };
        el.querySelector('button').addEventListener('click', remove);
        setTimeout(remove, ttl);
      }catch{}
    }

    // Override alert fallback (optional, non-blocking)
    window._alert = window.alert; window.alert = (m)=>showToast(m,'warn',4200);

    function updateTotals(){
      if(!document.getElementById('total-ths')) return; // safety
      if(!Array.isArray(minerState) || !minerState.length){
        document.getElementById('total-ths').textContent='—';
        document.getElementById('total-miner-power').textContent='—';
        document.getElementById('miners-count').textContent='0';
        document.getElementById('avg-miner-power').textContent='—';
        const effEl = document.getElementById('efficiency'); if (effEl) effEl.textContent='—';
        const absEl = document.getElementById('surplus-absorption'); if (absEl) absEl.textContent='—';
        return;
      }
      let sumTHs = 0, sumPower = 0, count = 0;
      for (const m of minerState){
        const th = getTHs(m); if (th != null) sumTHs += th;
        const pw = getPower(m); if (pw != null) sumPower += pw;
        count++;
      }
      document.getElementById('miners-count').textContent = count;
      document.getElementById('total-ths').textContent = fmtTHs(sumTHs);
      document.getElementById('total-miner-power').textContent = fmtW(sumPower);
      document.getElementById('avg-miner-power').textContent = (sumPower && count) ? fmtW(sumPower / count) : '—';

      // Efficiency (W/TH)
      const effEl = document.getElementById('efficiency');
      if (effEl){
        if (sumTHs > 0 && sumPower > 0){
          const wPerTh = sumPower / sumTHs; // already W per TH
          const valStr = wPerTh.toFixed(1) + ' W/TH';
          // Trend indicator
            if (lastEfficiency != null){
              if (wPerTh < lastEfficiency - 0.5){
                document.getElementById('efficiency-note').innerHTML = 'Improved <span class="trend-up">↓</span>'; // lower is better
              } else if (wPerTh > lastEfficiency + 0.5){
                document.getElementById('efficiency-note').innerHTML = 'Worse <span class="trend-down">↑</span>';
              } else {
                document.getElementById('efficiency-note').textContent = 'Stable';
              }
            }
          effEl.textContent = valStr;
          lastEfficiency = wPerTh;
        } else {
          effEl.textContent = '—';
          document.getElementById('efficiency-note').textContent = 'W / TH (lower is better)';
        }
      }

      // Surplus absorption (%)
      const absEl = document.getElementById('surplus-absorption');
      if (absEl){
        if (sumPower > 0 && lastGridPowerTotal != null){
          let exported = lastGridPowerTotal < 0 ? -lastGridPowerTotal : 0; // negative = exporting surplus
          // exported includes miner contribution already; to approximate available surplus, treat exported after miners are accounted for.
          // Absorption = minerPower / (minerPower + exported)
          const denom = sumPower + exported;
          const pct = denom > 0 ? (sumPower / denom) * 100 : 0;
          absEl.textContent = pct.toFixed(1) + ' %';
        } else {
          absEl.textContent = '—';
        }
      }
    }

    // Patch renderMiners to call updateTotals after rendering
    const _renderMinersOrig = renderMiners;
    renderMiners = function(miners){
      _renderMinersOrig(miners);
      try { updateTotals(); } catch(_){}
    };

    let latestGridPower = null; // track for derived stats

    // Override renderPower to also update derived surplus metrics
    const _renderPowerOrig = renderPower;
    renderPower = function(payload){
      _renderPowerOrig(payload);
      try{
        if(payload && payload.power){
          const p = payload.power; const pt = Number(p.total ?? (p.l1||0)+(p.l2||0)+(p.l3||0));
          if(isFinite(pt)) latestGridPower = pt; else latestGridPower = null;
          updateDerivedStats();
        }
      }catch(_){ /* ignore */ }
    };

    function updateEfficiency(sumTHs, sumPowerW){
      const elTHkW = document.getElementById('eff-ths-kw');
      if(!elTHkW) return; // card may not exist
      const elJTH = document.getElementById('eff-jth');
      const elTHKW = document.getElementById('eff-thkw');
      if(!sumTHs || !sumPowerW){
        elTHkW.textContent = '—';
        elJTH.textContent = '—';
        elTHKW.textContent = '—';
        return;
      }
      const kw = sumPowerW / 1000;
      const thPerKW = sumTHs / kw; // TH/s per kW
      const jPerTH = sumPowerW / sumTHs; // W per (TH/s)
      elTHkW.textContent = thPerKW ? `${thPerKW.toFixed(2)} TH/kW` : '—';
      elJTH.textContent = jPerTH ? `${jPerTH.toFixed(0)} W/TH` : '—';
      elTHKW.textContent = thPerKW ? `${thPerKW.toFixed(2)}` : '—';
    }

    function updateAbsorption(sumPowerW){
      const pctEl = document.getElementById('absorption-percent'); if(!pctEl) return;
      const wattsEl = document.getElementById('absorption-watts');
      const exportEl = document.getElementById('export-watts');
      if(sumPowerW == null || !isFinite(sumPowerW)){
        pctEl.textContent='—'; wattsEl.textContent='—'; exportEl.textContent='—'; return;
      }
      const exportW = latestGridPower != null && latestGridPower < 0 ? Math.abs(latestGridPower) : 0;
      exportEl.textContent = fmtW(exportW);
      wattsEl.textContent = fmtW(sumPowerW);
      if(exportW === 0){
        pctEl.textContent = '100%';
        return;
      }
      const pct = (sumPowerW / (sumPowerW + exportW))*100;
      pctEl.textContent = isFinite(pct) ? pct.toFixed(1)+ '%' : '—';
    }

    function updateDerivedStats(){
      // Called after miner or grid updates
      if(!Array.isArray(minerState) || !minerState.length){
        updateEfficiency(null,null); updateAbsorption(null); return;
      }
      let sumTHs=0, sumPower=0; let anyTH=false, anyP=false;
      for(const m of minerState){
        const th = getTHs(m); if(th!=null){ sumTHs+=th; anyTH=true; }
        const pw = getPower(m); if(pw!=null){ sumPower+=pw; anyP=true; }
      }
      updateEfficiency(anyTH?sumTHs:null, anyP?sumPower:null);
      updateAbsorption(anyP?sumPower:null);
    }

    // Patch updateTotals to also run derived stats
    const _updateTotalsOrig = updateTotals;
    updateTotals = function(){ _updateTotalsOrig(); try{ updateDerivedStats(); }catch(_){} };

    // Improve toggle ARIA sync
    const autoToggleEl = document.getElementById('auto-toggle');
    autoToggleEl.addEventListener('change', ()=>{ autoToggleEl.setAttribute('aria-checked', autoToggleEl.checked ? 'true':'false'); });

    // Initial ARIA state
    autoToggleEl.setAttribute('aria-checked','false');
  </script>
</body>
</html>
